<?php
/**
 * @package   admintoolswp
 * @copyright Copyright (c)2017-2024 Nicholas K. Dionysopoulos / Akeeba Ltd
 * @license   GNU GPL version 3 or later
 */

namespace Akeeba\AdminTools\Admin\Model;

use Akeeba\AdminTools\Admin\Helper\Wordpress;
use Akeeba\AdminTools\Library\Encrypt\Randval;
use Akeeba\AdminTools\Library\Mvc\Model\Model;
use DateTime;
use DateTimeZone;

defined('ADMINTOOLSINC') or die;

class AdminPassword extends Model
{
	/**
	 * The username for the administrator password protection
	 *
	 * @var  string
	 */
	public $username = '';

	/**
	 * The password for the administrator password protection
	 *
	 * @var  string
	 */
	public $password = '';

	/**
	 * Should I reset custom error pages?
	 *
	 * @var   bool
	 *
	 * @since 1.0.5
	 */
	public $resetErrorPages;

	/**
	 * Applies the back-end protection, creating an appropriate .htaccess and
	 * .htpasswd file in the administrator directory.
	 *
	 * @return  bool
	 */
	public function protect()
	{
		$cryptpw      = $this->apacheEncryptPassword();
		$htpasswd     = $this->username . ':' . $cryptpw . "\n";
		$htpasswdPath = ABSPATH . 'wp-admin/.htpasswd';
		$htaccessPath = ABSPATH . 'wp-admin/.htaccess';

		if (!@file_put_contents($htpasswdPath, $htpasswd))
		{
			return false;
		}

		$path = rtrim(ABSPATH . 'wp-admin', '/\\') . '/';
		$date = new DateTime();
		$tz   = new DateTimeZone(Wordpress::get_timezone_string());
		$date->setTimezone($tz);

		$d        = $date->format('Y-m-d H:i:s T');
		$version  = ADMINTOOLSWP_VERSION;
		$htaccess = <<< HTACCESS
################################################################################
## Administrator Password Protection
##
## This file was generated by Admin Tools $version on $d
################################################################################

<IfModule mod_auth_basic.c>
	AuthUserFile "$path.htpasswd"
	AuthName "Restricted Area"
	AuthType Basic
	Require valid-user
</IfModule>

<IfModule mod_rewrite.c>
	RewriteEngine On
	RewriteRule \.htpasswd$ - [F,L]
</IfModule>

HTACCESS;

		if ($this->resetErrorPages)
		{
			$htaccess .= <<< HTACCESS
## Reset custom error pages to default
#
# Prevents a 404 error when trying to access your site's wp-admin directory
#
ErrorDocument 401 default
ErrorDocument 403 default

HTACCESS;

		}

		$htaccess .= <<< HTACCESS
## Always allow access to admin-ajax.php
<Files "admin-ajax.php">
	<IfModule !mod_authz_core.c>
		Order allow,deny
		Allow from all
		Satisfy any 
	</IfModule>
	<IfModule mod_authz_core.c>
		<RequireAny>
			Require all granted
		</RequireAny>
	</IfModule>
</Files>



# Always allow access to media directories, they're used for login and password reset
<IfModule mod_setenvif.c>
	SetEnvIf Request_URI "css/" allow_media_folder
	SetEnvIf Request_URI "js/" allow_media_folder
	SetEnvIf Request_URI "images/" allow_media_folder
</IfModule>
<IfModule !mod_authz_core.c>
	Order allow,deny
	Allow from env=allow
	Satisfy any
</IfModule>
<IfModule mod_authz_core.c>
	<RequireAny>
		Require env allow_media_folder
	</RequireAny>
</IfModule>

HTACCESS;


		$status = @file_put_contents($htaccessPath, $htaccess);

		if (!$status || !is_file($path . '/.htpasswd'))
		{
			@unlink($htpasswdPath);

			return false;
		}

		return true;
	}

	/**
	 * Removes the administrator protection by removing both the .htaccess and
	 * .htpasswd files from the administrator directory
	 *
	 * @return bool
	 */
	public function unprotect()
	{
		$htaccessPath = ABSPATH . 'wp-admin/.htaccess';
		$htpasswdPath = ABSPATH . 'wp-admin/.htpasswd';

		if (!@unlink($htaccessPath))
		{
			return false;
		}

		if (!@unlink($htpasswdPath))
		{
			return false;
		}

		return true;
	}

	/**
	 * Returns true if both a .htpasswd and .htaccess file exist in the back-end
	 *
	 * @return bool
	 */
	public function isLocked()
	{
		$htaccessPath = ABSPATH . 'wp-admin/.htaccess';
		$htpasswdPath = ABSPATH . 'wp-admin/.htpasswd';

		return @file_exists($htpasswdPath) && @file_exists($htaccessPath);
	}

	protected function apacheEncryptPassword()
	{
		$os = strtoupper(PHP_OS);
		$isWindows = substr($os, 0, 3) == 'WIN';

		$encryptedPassword = null;

		// Iterated and salted MD5 (APR1)
		$rand = new Randval();
		$salt = $rand->generateString(4);
		$encryptedPassword = $this->apr1_hash($this->password, $salt, 1000);

		// SHA-1 encrypted – should never run
		if (empty($encryptedPassword) && function_exists('base64_encode') && function_exists('sha1'))
		{
			$encryptedPassword = '{SHA}' . base64_encode(sha1($this->password, true));
		}

		// Traditional crypt(3) – should never run
		if (empty($encryptedPassword) && function_exists('crypt') && !$isWindows)
		{
			$salt              = $rand->generateString(2);
			$encryptedPassword = crypt($this->password, $salt);
		}

		// If all else fails use plain text passwords (only happens on Windows)
		if (empty($encryptedPassword))
		{
			$encryptedPassword = $this->password;
		}

		return $encryptedPassword;
	}

	/**
	 * Perform the hashing of the password
	 *
	 * @param   string  $password    The plain text password to hash
	 * @param   string  $salt        The 8 byte salt to use
	 * @param   int     $iterations  The number of iterations to use
	 *
	 * @return  string  The hashed password
	 */
	protected function apr1_hash($password, $salt, $iterations)
	{
		$len  = strlen($password);
		$text = $password . '$apr1$' . $salt;
		$bin  = md5($password . $salt . $password, true);

		for ($i = $len; $i > 0; $i -= 16)
		{
			$text .= substr($bin, 0, min(16, $i));
		}

		for ($i = $len; $i > 0; $i >>= 1)
		{
			$text .= ($i & 1) ? chr(0) : $password[0];
		}

		$bin = $this->apr1_iterate($text, $iterations, $salt, $password);

		return $this->apr1_convertToHash($bin, $salt);
	}

	protected function apr1_iterate($text, $iterations, $salt, $password)
	{
		$bin = md5($text, true);

		for ($i = 0; $i < $iterations; $i++)
		{
			$new = ($i & 1) ? $password : $bin;

			if ($i % 3)
			{
				$new .= $salt;
			}

			if ($i % 7)
			{
				$new .= $password;
			}

			$new .= ($i & 1) ? $bin : $password;
			$bin = md5($new, true);
		}

		return $bin;
	}

	protected function apr1_convertToHash($bin, $salt)
	{
		$tmp = '$apr1$' . $salt . '$';

		$tmp .= $this->apr1_to64(
			(ord($bin[0]) << 16) | (ord($bin[6]) << 8) | ord($bin[12]),
			4
		);

		$tmp .= $this->apr1_to64(
			(ord($bin[1]) << 16) | (ord($bin[7]) << 8) | ord($bin[13]),
			4
		);

		$tmp .= $this->apr1_to64(
			(ord($bin[2]) << 16) | (ord($bin[8]) << 8) | ord($bin[14]),
			4
		);

		$tmp .= $this->apr1_to64(
			(ord($bin[3]) << 16) | (ord($bin[9]) << 8) | ord($bin[15]),
			4
		);

		$tmp .= $this->apr1_to64(
			(ord($bin[4]) << 16) | (ord($bin[10]) << 8) | ord($bin[5]),
			4
		);

		$tmp .= $this->apr1_to64(
			ord($bin[11]),
			2
		);

		return $tmp;
	}

	/**
	 * Convert the input number to a base64 number of the specified size
	 *
	 * @param   int  $num   The number to convert
	 * @param   int  $size  The size of the result string
	 *
	 * @return  string  The converted representation
	 */
	protected function apr1_to64($num, $size)
	{
		static $seed = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

		$result = '';

		while (--$size >= 0)
		{
			$result .= $seed[$num & 0x3f];
			$num >>= 6;
		}

		return $result;
	}
}
